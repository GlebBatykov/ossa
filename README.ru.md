</div>

<div align="center">

**Языки:**
  
[![English](https://img.shields.io/badge/Language-English-blue?style=?style=flat-square)](README.md)
[![Russian](https://img.shields.io/badge/Language-Russian-blue?style=?style=flat-square)](README.ru.md)

</div>

- [Введение](#введение)
- [Про Ossa](#про-ossa)
- [Установка](#установка)
- [Что такое задача](#что-такое-задача)
  - [Типы задач](#типы-задач)
  - [Запуск задачи](#запуск-задачи)
  - [Получение результата](#получение-результата)
- [Обработка ошибок](#обработка-ошибок)

# Введение

Ранее в целях упрощения взаимодействиями с изолятами в Dart я начал разрабатывать акторный фреймворк - [Theater](#).

Однако не всем может прийти по вкусу как сама акторная модель которую реализуют изоляты в Dart так и акторный фреймворк.

Помимо Dart-а я так же пишу на C# и там есть, как по мне, удобная обертка для работы с многопоточностью - Task.

Я решил сделать в Dart нечто максимально похожее на Task в C#, однако с некоторыми ньюансами из за того что все же под капотом используются изоляты.

# Про Ossa

Предоставляет удобную обертку для работы с изолятами похожую на Task в C#.

# Установка

# Что такое задача

Каждая задача запускается и работает в отдельном изоляте, задачи могут возвращать некий результат.

Как уже было сказанно в введении я пытался сделать задачи максимально похожими на Task в C#. Однако есть и различия.

К примеру отсутствие вместо пула изолятов (в C# пул потоков) к которым переадресуются задачи и затем выполняются, в Ossa каждая создаваемая вами задача имеет собственный изолят.

Каждая задача управляет жизненным циклом своего изолята.

## Типы задач

Задачи бывают двух типов:

- одноразовые задачи (по умолчанию);
- переиспользуемые задачи.

Различие между этими двумя типами состоит в том что одноразовые задачи после завершения выполнения задачи (в том числе если выполнение завершилось ошибкой) - вызывают свой метод dispose, уничтожают свой изолят и закрывают все используемые ими StreamController-ы, то есть освобождает все используемые ей ресурсы. Переиспользуемые задачи этого не делают, расчитанно это на то что вы создав задачу будете использовать её неоднократно.

Зачем использовать переиспользуемую задачу, а не создавать в будущем, при необходимости новую задачу? - чтобы каждый раз не создавать новый изолят.

## Запуск задачи

Запустить задачу можно двумя способами:

- при помощи метода run;
- создав задачу, проиницализировав её и самостоятельно её запустив.

Пример запуска при помощи метода run:

```dart
void main() async {
  // Create and run Task using run method
  var task = await Task.run((context) {
    print('Hello, from task!');
  });

  // Wait when task is completed
  await task.result();
}
```

Пример запуска создавая задачу, проинициализировав её и запустив:

```dart
void main() async {
  // Create task
  var task = Task((context) {
    print('Hello, from task!');
  });

  // Initialize task before work with him
  await task.initialize();

  // Start task
  await task.start();

  // Whait when task is completed
  await task.result();
}
```

## Получение результата

Задача может возвратить результат выполнения. При создании задачи самостоятельно, либо создании и запуске при помощи метода run вы можете указать Generic тип, который должен вернуть Task.

Можно обработать получение результата как ассинхронно при помощи onDone обработчика, так и дождаться получения результата при помощи Future полученного при вызове метода result.

Метод result в случае когда задача выполняется подождет результата из изолята, а затем вернет его. Если же задача на момент вызова метода result уже завершена и не запущенна повторно, то он вернет результат от предыдущего запуска задачи.

Получение результата из Future полученного при вызове метода result:

```dart
void main() async {
  // Create and run Task with double return type using run method
  var task = await Task.run<double>((context) => 3 * 7);

  // Wait result from Task
  var result = await task.result();

  print(result);
}
```

Ожидаемый вывод:

```dart
21
```

Ассинхронное получение результата при помощи onDone обработчика:

```dart
void main() async {
  // Create and run task with int return type, set onDone handler
  var task = await Task.run<int>((context) {
    return 5 * 10;
  }, onDone: (value) async {
    print(value);
  });
}
```

Ожидаемый вывод:

```dart
50
```

# Обработка ошибок

Во время выполнения задачи может возникнуть исключение.

Есть варианта его обработки:

- обработка при помощи onError обработчика;
- заключение части кода с ожиданием результата в try/catch.

Пример обработки исключения при помощи onError обработчика, ассинхронно обрабатывая результат выполнения задачи:

```dart
void main() async {
  late Task task;

  // Create and run Task using run method, set onError handler
  task = await Task.run<void>((context) {
    throw FormatException();
  }, onError: (error) async {
    print(error.object.toString());

    task.dispose();
  });
}
```

Если при старте задачи не был задан onError обработчик, то есть 2 сценария что произойдет с ним:

- если вы ожидаете результат задачи ассинхронно, то есть при помощи onDone обработчика, то ничего не произойдет, исключение не будет никак обработанно. Задача из статуса выполнения () перейдет в статус готова к выполнению ();
- если вы ожидаете результат задачи при помощи метода result, то исключение будет вызванно повторно вызванно уже в методе result.

Пример обработки исключения без onError обработчика, ожидая результат при помощи метода result:

```dart
void main() async {
  // Create and run Task using run method
  var task = await Task.run((context) {
    throw FormatException();
  });

  try {
    // Wait when task is completed
    await task.result();
  } catch (object) {
    // Handle error

    if (object is TaskCompleteException) {
      print(object);

      await task.dispose();
    }
  }
}
```
