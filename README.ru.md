</div>

<div align="center">

**Языки:**
  
[![English](https://img.shields.io/badge/Language-English-blue?style=?style=flat-square)](README.md)
[![Russian](https://img.shields.io/badge/Language-Russian-blue?style=?style=flat-square)](README.ru.md)

</div>

- [Введение](#введение)
- [Про Ossa](#про-ossa)
- [Установка](#установка)
- [Что такое задача](#что-такое-задача)
  - [Типы задач](#типы-задач)
  - [Запуск задачи](#запуск-задачи)
  - [Получение результата](#получение-результата)
- [Обработка ошибок](#обработка-ошибок)

# Введение

Ранее в целях упрощения взаимодействиями с изолятами в Dart я начал разрабатывать акторный фреймворк - [Theater](#).

Однако не всем может прийти по вкусу как сама акторная модель которую реализуют изоляты в Dart так и акторный фреймворк.

Помимо Dart-а я так же пишу на C# и там есть, как по мне, удобная обертка для работы с многопоточностью - Task.

Я решил сделать в Dart нечто максимально похожее на Task в C#, однако с некоторыми ньюансами из за того что все же под капотом используются изоляты.

# Про Ossa

Предоставляет удобную обертку для работы с изолятами похожую на Task в C#.

# Установка

# Что такое задача

Каждая задача запускается и работает в отдельном изоляте, задачи могут возвращать некий результат.

Как уже было сказанно в введении я пытался сделать задачи максимально похожими на Task в C#. Однако есть и различия.

К примеру отсутствие вместо пула изолятов (в C# пул потоков) к которым переадресуются задачи и затем выполняются, в Ossa каждая создаваемая вами задача имеет собственный изолят.

Каждая задача управляет жизненным циклом своего изолята.

## Типы задач

Задачи бывают двух типов:
- одноразовые задачи (по умолчанию);
- переиспользуемые задачи.

Различие между этими двумя типами состоит в том что одноразовые задачи после завершения выполнения задачи (в том числе если выполнение завершилось ошибкой) - вызывают свой метод dispose, уничтожают свой изолят и закрывают все используемые ими StreamController-ы, то есть освобождает все используемые ей ресурсы. Переиспользуемые задачи этого не делают, расчитанно это на то что вы создав задачу будете использовать её неоднократно.

Зачем использовать переиспользуемую задачу, а не создавать в будущем, при необходимости новую задачу? - чтобы каждый раз не создавать новый изолят.

## Запуск задачи

Запустить задачу можно двумя способами:
- при помощи метода run;
- создав задачу, проиницализировав её и самостоятельно её запустив.

Пример запуска при помощи метода run:

```dart
```

Пример запуска создавая задачу, проинициализировав её и запустив:

```dart
```

## Получение результата

Задача может возвратить результат выполнения. При создании задачи самостоятельно, либо создании и запуске при помощи метода run вы можете указать Generic тип, который должен вернуть Task.

Можно обработать получение результата как ассинхронно при помощи onDone обработчика, так и дождаться получения результата при помощи Future полученного при вызове метода result.

Метод result в случае когда задача выполняется подождет результата из изолята, а затем вернет его. Если же задача на момент вызова метода result уже завершена и не запущенна повторно, то он вернет результат от предыдущего запуска задачи.

Получение результата из Future полученного при вызове метода result:

```dart

```

Ассинхронное получение результата при помощи onDone обработчика:

```dart

```

# Обработка ошибок

Во время выполнения задачи может возникнуть исключение.

Есть варианта его обработки:
- обработка при помощи onError обработчика;
- заключение части кода с ожиданием результата в try/catch.

Пример обработки исключения при помощи onError обработчика, ассинхронно обрабатывая результат выполнения задачи:

```dart
```

Если при старте задачи не был задан onError обработчик, то есть 2 сценария что произойдет с ним:
- если вы ожидаете результат задачи ассинхронно, то есть при помощи onDone обработчика, то ничего не произойдет, исключение не будет никак обработанно. Задача из статуса выполнения () перейдет в статус готова к выполнению ();
- если вы ожидаете результат задачи при помощи метода result, то исключение будет вызванно повторно вызванно уже в методе result.

Пример обработки исключения без onError обработчика
